1)Where:– filters rows based on a specified condition.
2)Limit:– gets a subset of rows generated by a query.
3)Fetch:– limits the number of rows returned by a query.
4)In:– selects data that matches any value in a list of values.
5)Between:– selects data that is a range of values.
6)Like:– filters data based on pattern matching.
7)Is Null:– checks if a value is null or not.



*****1)Where – filters rows based on a specified condition.
--syntax:- select column_1, column_2, column_3 from table_name where condition;

The WHERE clause appears right after the FROM clause of the SELECT statement. The conditions are used to filter the rows returned from the SELECT statement. PostgreSQL provides you with various standard operators  to construct the conditions.

The following table illustrates the standard comparison operators.
Operator	Description
=		Equal
>		Greater than
<		Less than
>=		Greater than or equal
<=		Less than or equal
<> or !=	Not equal
AND		Logical operator AND
OR		Logical operator OR


*****2)Limit – gets a subset of rows generated by a query.
--syntax:- select * from table_name limit n;
	The statement return n rows generated by query.If n is zero or null, the query returns the same result set as omitting the limit clause.

2.1)offset:- In case you want to skip a number of rows before returning the n rows, you use OFFSET clause placed after the LIMIT clause
--syntax:- select * from table_name limit n offset m;

The statement first skips m rows before returning n rows generated by the query. If m is zero, the statement will work like without the OFFSET clause.

Because the order of the rows in the database table is unpredictable, when you use the LIMIT clause, you should always use the ORDER BY clause to control the order of rows. If you don’t do so, you will get an unpredictable result set.

--syntax:- select column_1, column_2 from table_name order by column_1 limit n offset m;


*****3)FETCH :– limits the number of rows returned by a query.

To limit the number of rows returned by a query, you often use the LIMIT clause. The LIMIT clause is widely used by many relational database management systems such as MySQL, H2, and HSQLDB. However, the LIMIT clause is not a SQL-standard.

To conform with the SQL standard, PostgreSQL provides the FETCH clause to retrieve a portion of rows returned by a query. Note that the FETCH clause was introduced in SQL:2008.

--syntax:- a)select column_1, column_2 form table_name order by column_1 fetch first row only;
	 b)select column_1, column_2 form table_name order by column_1 fetch first 1 row only;
	 c)select column_1, column_2 form table_name order by column_1 fetch first 5 row only;


*****4)IN :– selects data that matches any value in a list of values.
--syntax:- value in (value_1, value_2)

The expression returns true if the value matches any value in the list i.e., value1 and value2. The list of values can be a list of numbers or strings or the result set of a SELECT statement.
--syntax:-value IN (SELECT value FROM tbl_name);
The statement inside the parentheses is called a subquery which is a query nested inside another query.

**PostgreSQL IN operator examples

Suppose you want to know the rental information of customer id 1 and 2, you can use the IN operator in the WHERE clause as follows:
--syntax:- SELECT customer_id,rental_id,return_date FROM rental WHERE customer_id IN (1, 2) ORDER BY return_date DESC;

You can use the equal (=) and OR operators to rewrite the query above as follows:
--syntax:-select customer_id, rental_id, return_date from rental where customer_id = 1 or customer_id = 2 order by return date desc;

The query that uses the IN operator is shorter and more readable than the query that uses equal (=) and OR operators. In addition, PostgreSQL executes the query with the IN operator much faster than the same query that uses a list of OR operators.


**PostgreSQL NOT IN operator

You can combine the IN operator with the NOT operator to select rows whose values do not match the values in the list. The following statement find all rentals with the customer id is not 1 or 2.
--syntax:- SELECT customer_id,rental_id,return_date FROM rental WHERE customer_id not in (1, 2) ORDER BY return_date DESC;

You can also rewrite the NOT IN operator by using the not equal (<>) and the AND operators as follows:
--syntax:- SELECT customer_id,rental_id,return_date FROM rental WHERE customer_id <> 1 and customer_id <> 2 ORDER BY return_date DESC;

Note:- in = or
       not in = and


**PostgreSQL IN with a subquery

The following query returns a list of customer id of customers that has rental’s return date on 2005-05-27:
--query:- select customer_id, rental_date from rental where cast(rental_date as date) = '2005-05-27';

You can use the list of customer id as the input for the IN operator as follows:
--syntax:- SELECT first_name,last_name FROM customer 
	   WHERE customer_id IN 
	   (SELECT customer_id FROM rental WHERE CAST (return_date AS DATE) = '2005-05-27');


5)Between:– selects data that is a range of values.
--synatx:- select colimn_1, column_2 from table_name where column_1 between value_1 and value_2
--synatx:- select colimn_1, column_2 from table_name where column_1 not between value_1 and value_2


6)Like:– filters data based on pattern matching.

**Introduction to PostgreSQL LIKE operator

Note :- like operator is case-sensitive.
	ilike operator is case-insensitively.

Suppose the store manager asks you find a customer that he does not remember the name exactly. He just remembers that customer’s first name begins with something like Jen. How do you find the exact customer that the store manager is asking? You may find the customer in the  customer table by looking at the first name column to see if there is any value that begins with Jen. It is kind of tedious because there many rows in the customer table.
--syntax:-select column_1, colmn_2 from table_name where column_1 like 'pattern%'
--query:-select first_name, last_name form customer where first_name like 'Jen%';

Notice that the WHERE clause contains a special expression: the first_name, the LIKE operator and a string that contains a percent (%) character, which is referred as a pattern.

**PostgreSQL provides two wildcard characters:

Percent ( %)  :-for matching any sequence of characters.
Underscore ( _)  :-for matching any single character.

In (_)pattern you can say that length of charater will be fix depends on the number of underscore(_) and character used.

If the pattern does not contain any wildcard character, the LIKE operator acts like the equal ( =) operator.

**PostgreSQL LIKE examples

SELECT
 'foo' LIKE 'foo', -- true
 'foo' LIKE 'f%', -- true
 'foo' LIKE '_o_', -- true
 'bar' LIKE 'b_'; -- false

How it works.

a) The first expression returns true because the foo pattern does not contain any wildcard character so the LIKE operator acts like the equal(=) operator.
b) The second expression returns true because it matches any string that begins with the letter  f and followed by any number of characters.
c) The third expression returns true because the pattern (_o_) matches any string that begins with any single character, followed by the letter o and ends with any single character.
d) The fourth expression returns false because the pattern  (b_) matches any string that begins with the letter  b and followed by any single character.


**You can use the wildcard character at the beginning and/or end of the pattern. For example, the following query returns customers whose first name contains  er string e.g., Jenifer, Kimberly, etc.
--query:- select first_name from customer where first_name like %er%;

**You can combine the percent ( %) with underscore ( _) to construct a pattern as the following
example:- select column_1 form table_name
	  where column_1 like '_her%';
output:- The expression matches customer whose first name begins with any single character, is followed by the literal string her, and ends with any number of characters.



7)Is Null:– checks if a value is null or not.
--syntax:- select column_1, column_2 from table_name where column_1 is null;

**not null
--syntax:- select column_1, column_2 drom table_name where column_1 is not null;
